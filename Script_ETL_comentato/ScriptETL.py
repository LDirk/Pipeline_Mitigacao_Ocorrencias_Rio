# -*- coding: utf-8 -*-
"""ETL_ENG_dados.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JOuL281yp7o4SJUzyipfqZpUVq7-vHSB
"""

# Bibliotecas utilizadas

import pandas as pd
import requests
from datetime import datetime, timedelta
import pytz
import os.path
import csv

'''
O dataset deve ter:

# tipo_ocorrencia: Tipo da ocorrência observada (titulo)

# datetime: Data e horário de verificação das ocorrências na API

# status_ocorrencia: Status da ocorrência no horário observado (status)

# quantidade_ocorrencia: Número de ocorrências neste status

'''

# Pegando todas as ocorrências abertas.

# Define a URL da API para obter as ocorrências abertas.
url = 'https://api.dados.rio/v2/adm_cor_comando/ocorrencias_abertas'

# Envia uma solicitação GET para a URL e recebe a resposta da API.
response = requests.get(url)

# Converte a resposta em formato JSON para um dicionário Python.
data = response.json()

#Extrai a lista de eventos do dicionário.
eventos = data['eventos']

#Cria um DataFrame a partir da lista de eventos.
df_ocorrencias = pd.DataFrame(eventos)

# Deixando somente as colunas desejadas
df_ocorrencias = df_ocorrencias[[ 'titulo', 'status', 'inicio', 'informe_id', 'id', 'pop_id' ]]


# Pegando todas as ocorrências abertas por orgao
import requests

# Obtendo a data e hora atual no fuso horário de São Paulo
current_datetime = datetime.now(pytz.timezone('America/Sao_Paulo'))

# URL base para obter as ocorrências por orgão responsável
base_url = 'https://api.dados.rio/v2/adm_cor_comando/ocorrencias_orgaos_responsaveis/?eventoId='

# DataFrame para armazenar os dados das ocorrências por orgão
df_org = pd.DataFrame()

# Iterando sobre os IDs das ocorrências
for evento_id in df_ocorrencias['id']:
    url = base_url + str(evento_id)
    response = requests.get(url)

    if response.status_code == 200:
        data = response.json()
        eventos = data['atividades']

        # Adicionando a chave "id" ao dicionário do evento com o valor do evento_id
        for evento in eventos:
            evento['id'] = evento_id
        df_org = pd.concat([df_org, pd.DataFrame(eventos)])

# Filtrando somente as ocorrências do orgão 'CET-RIO' em andamento (status = "PRESENTE")
df_CET_RIO = df_org.loc[(df_org['orgao'] == 'CET-RIO')]
df_CET_RIO = df_CET_RIO.sort_values(by='inicio', ascending=False)

# Adicionando a coluna 'data_consulta_api' com a data e hora atual
df_CET_RIO['data_consulta_api'] = current_datetime.strftime("%Y-%m-%d %H:%M")

# Reindexando o DataFrame
df_CET_RIO.reset_index(drop=True, inplace=True)

# Existem 2 eventos, id = '90516' e '98964' que possuem informações de chegada e início vazias, irei manter esse evento no conjunto de dados.



# Realiza um merge entre os DataFrames df_CET_RIO e df_ocorrencias com base na coluna 'id', mantendo apenas as colunas 'id' e 'titulo' do DataFrame df_ocorrencias.
df_final = df_CET_RIO.merge(df_ocorrencias[['id', 'titulo']], on='id', how='left')


# Seleciona apenas as colunas 'titulo', 'data_consulta_api', 'status' e 'id' do DataFrame df_final. Somente elas serão utilizadas
df_final = df_final.loc[:, ['titulo', 'data_consulta_api', 'status', 'id']]

# Remove as linhas duplicadas do DataFrame df_final, considerando todas as colunas.
'''
Motivo das duplicadas :Alguns chamados possuem mais de uma descrição, porém possuem o mesmo ID ,
ou seja é apenas um com chamado com 2 descrições, então, irá duplicar as linhas.
'''
df_final = df_final.drop_duplicates()

# Check
# df_final.sort_values(by='titulo', ascending=True).head()

'''
Agrupa os dados do DataFrame df_final por 'titulo', 'data_consulta_api' e 'status' e
calcula a contagem de ocorrências em cada grupo usando o método size().
'''
df_csv = df_final.groupby(['titulo', 'data_consulta_api', 'status']).size().reset_index()

# Renomeia as colunas
df_csv.columns = ['Tipo_De_Ocorrencia', 'Data_Consulta_Api', 'Status', 'Quantidade_De_Ocorrencias']

# Ordena o DataFrame df_csv com base na coluna 'Tipo_De_Ocorrencia' e 'Data_Consulta_Api'.
df_csv = df_csv.sort_values(by=['Tipo_De_Ocorrencia', 'Data_Consulta_Api'], ascending=[True, False])

'''
  Verifica se o arquivo CSV já existe.
  Se o arquivo não existir, o DataFrame df_csv é salvo no arquivo CSV usando o método to_csv().
  Caso contrário, o arquivo é aberto no modo de adição ('a') usando a função open().
  Em seguida, é criado um objeto writer usando a classe csv.writer para escrever as linhas do DataFrame df_csv no arquivo CSV usando o método writerows().
'''

filename = 'dados/dados_ocorrencias2.csv'

if not os.path.isfile(filename):
    df_csv.to_csv(filename, index=False)
else:
    with open(filename, 'a', newline='') as file:
      writer = csv.writer(file)
      writer.writerows(df_csv.values)


